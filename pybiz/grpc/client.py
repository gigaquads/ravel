import grpc

from .driver import GrpcDriver


class GrpcClient(object):
    """
    GrpcClient must define all RPC service methods defined in the protobuf
    service file. Each method must return a single "request" argument, which is
    the sole protobuf message object passed into the underlying gRPC "stub"
    method.
    """

    def __init__(
            self,
            driver: GrpcDriver,
            secure_port=None,
            insecure_port=None,
            ):

        assert insecure_port or secure_port

        self._driver = driver
        self._insecure_port = insecure_port
        self._secure_port = secure_port
        self._channel = self._new_channel()
        self._stub = self._driver.stub_class(self._channel)
        self._method_names = {
            attr for attr in dir(self._stub)
            if not attr.startswith('__')
            }

        def build_wrapper(func_name, func):
            """
            Decorate instance RPC methods with a decorator that takes the output
            of said methods and passes it in as the "request" argument to the
            grpc "stub" methods generated by grpcio.
            """
            def wrapper(*args, **kwargs):
                request = func(*args, **kwargs)
                grpc_stub_method = getattr(self._stub, func_name)
                return grpc_stub_method(request)

            wrapper.__name__ = '{}_wrapper'.format(func_name)
            return wrapper

        # replace/decorate RPC instance methods (decorator above)
        for method_name in self._method_names:
            method = getattr(self, method_name, None)

            # ensure we've implemented all RPC functions
            if not method or not callable(method):
                raise Exception('{} must implement {}'.format(
                    self.__class__.__name__, method_name))
            else:
                wrapper = build_wrapper(method_name, method)
                setattr(self, method_name, wrapper)

    def _new_channel(self):
        """
        Return a secure or insecure grpc channel object based on whether a
        secure_port or insecure_port was supplied to the constructor.
        """
        if self._insecure_port:
            return grpc.insecure_channel(self._insecure_port)
        else:
            return grpc.secure_channel(self._secure_port)

    @property
    def types(self) -> dict:
        return self._driver.types

    @property
    def methods(self) -> list:
        return self._method_names

    @property
    def channel(self):
        return self._channel


# Example Usage:
if __name__ == '__main__':
    import sys
    import time

    from .driver import GrpcDriver
    from .service import GrpcService

    # A pair of grpc modules is generated for each service by grpcio:
    # --------------------------
    import helloworld_pb2         # <- contains protobuf Message types
    import helloworld_pb2_grpc    # <- contains client/server components

    SOCKET_ADDR = '[::]:50052'

    # example server implementation:
    class GreeterService(GrpcService):
        def SayHello(self, request, context):
            """
            Create a reply and send it back to the client.
            """
            return self.types.HelloReply(message='Hi, {}'.format(request.name))

    # example client implementation:
    class GreeterClient(GrpcClient):
        def SayHello(self, name):
            """
            Prepare and return arguments to send to the server--namely, a hello
            request object.
            """
            return self.types.HelloRequest(name=name)

    # driver manages access to the autogenerated grpc modules
    driver = GrpcDriver(helloworld_pb2, helloworld_pb2_grpc)

    # run the server or client based on first CLI arg:
    if sys.argv[1].lower() == 'server':
        service = GreeterService(driver, insecure_port=SOCKET_ADDR)
        server = service.server()

        server.start()
        input('Press any key to kill the server...')

    else:
        client = GreeterClient(driver, insecure_port=SOCKET_ADDR)

        while True:
            name = input('Write your name (Enter nothing to quit): ').strip()
            if name:
                response = client.SayHello(name)
                print(response)
            else:
                break
